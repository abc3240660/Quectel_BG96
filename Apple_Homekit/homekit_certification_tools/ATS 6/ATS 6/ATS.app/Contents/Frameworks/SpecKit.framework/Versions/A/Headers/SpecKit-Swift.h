// Generated by Apple Swift version 4.2.1 (swiftlang-1000.11.42 clang-1000.11.45.1)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
@import AppKit;
@import CoreGraphics;
@import Foundation;
@import ObjectiveC;
@import Quartz;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="SpecKit",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSTableView;
@protocol NSDraggingInfo;
@class NSBundle;
@class NSCoder;

/// An <code>AuxiliaryFileBrowserController</code> helps your application manage files to be
/// used as specification lookup sources. This view controller would be optimally
/// placed with other configuration views in your app, such as a Preferences window.
/// The browser communicates with the shared <code>SpecificationManager</code> instance and
/// lists its auxiliary files to the user. It presents options for adding and
/// removing auxiliary files.
/// To initialize an <code>AuxiliaryFileBrowserController</code>, simply use the <code>standard()</code>
/// class function.
SWIFT_CLASS("_TtC7SpecKit30AuxiliaryFileBrowserController")
@interface AuxiliaryFileBrowserController : NSViewController <NSTableViewDataSource, NSTableViewDelegate>
@property (nonatomic, copy) NSString * _Nonnull instructionText;
- (void)viewDidLoad;
- (NSDragOperation)tableView:(NSTableView * _Nonnull)tableView validateDrop:(id <NSDraggingInfo> _Nonnull)info proposedRow:(NSInteger)row proposedDropOperation:(NSTableViewDropOperation)dropOperation SWIFT_WARN_UNUSED_RESULT;
- (BOOL)tableView:(NSTableView * _Nonnull)tableView acceptDrop:(id <NSDraggingInfo> _Nonnull)info row:(NSInteger)row dropOperation:(NSTableViewDropOperation)dropOperation SWIFT_WARN_UNUSED_RESULT;
- (BOOL)tableView:(NSTableView * _Nonnull)tableView shouldSelectRow:(NSInteger)row SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithNibName:(NSNibName _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end












/// Represents a unit of information to be displayed in a description of a spec
/// entry.
SWIFT_CLASS("_TtC7SpecKit20ObjCEntryDisplayItem")
@interface ObjCEntryDisplayItem : NSObject
/// The localized text describing the type of data that this display item
/// represents, such as “Summary” or “Related”.
@property (nonatomic, copy) NSString * _Nonnull label;
/// The displayable information for this item. This could be a string,
/// attributed string, image, or any format supported by the displaying view
/// controller.
@property (nonatomic) id _Nonnull objectValue;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

@class SpecificationEntry;
@class NSXMLNode;
@class NSXMLElement;

/// Instances of the <code>Specification</code> class encapsulate all interactions with
/// a specification document. When this class is used directly, it provides
/// XML parsing functionality allowing you to retrieve metadata about spec
/// chapters and other types of entries. However, you may use a subclass of
/// <code>Specification</code>, such as <code>PDFSpecification</code>, or create your own subclass
/// to support additional information about a spec.
SWIFT_CLASS("_TtC7SpecKit13Specification")
@interface Specification : NSObject
/// The name of the specification, as provided by the <code><name></code> tag directly
/// under the <code><spec></code> tag in the XML tree.
@property (nonatomic, readonly, copy) NSString * _Nonnull title;
/// A shorter name of the specification, as provided by the <code><shortname></code> tag
/// within the <code><spec></code> tag in the XML tree.
@property (nonatomic, readonly, copy) NSString * _Nonnull shortTitle;
/// The revision number of the specification, as provided by the <code>revision</code>
/// attribute of the <code><spec></code> tag.
@property (nonatomic, readonly, copy) NSString * _Nonnull revision;
/// The identifier string for the specification, as provided by the <code>id</code>
/// attribute of the <code><spec></code> tag. This defines the broad type of the
/// specification, such as “aispec”.
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
/// The variant of the specification, as provided by the <code>variant</code> attribute
/// of the <code><spec></code> tag.
@property (nonatomic, readonly, copy) NSString * _Nonnull variant;
/// The language of the specification, as provided by the <code>lang</code>
/// attribute of the <code><spec></code> tag.
@property (nonatomic, readonly, copy) NSString * _Nonnull language;
/// The version number of the specification, as provided by the <code>version</code>
/// attribute of the <code><spec></code> tag.
@property (nonatomic, readonly, copy) NSString * _Nonnull version;
/// Indicates whether the spec allows text and image previews to be shown.
@property (nonatomic, readonly) BOOL allowsPreviews;
/// The URL from which the specification’s XML map was loaded.
@property (nonatomic, readonly, copy) NSURL * _Nullable specMapURL;
/// The URL from which the DTD was loaded to validate the spec XML (or <code>nil</code> if
/// the DTD was embedded in the XML file).
@property (nonatomic, readonly, copy) NSURL * _Nullable dtdURL;
@property (nonatomic, readonly, copy) NSString * _Nonnull debugDescription;
/// The complete list of entries in the specification, keyed by their internal
/// labels.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, SpecificationEntry *> * _Nonnull entries;
/// \code
/// The number of entries stored in this specification.
///
/// \endcode
@property (nonatomic, readonly) NSInteger entryCount;
/// Searches the specification for an entry with the provided label,
/// and returns it if it exists. This method returns <code>nil</code> if no entry
/// has the specified label.
/// \param label A string that identifies a unique entry in the spec.
///
///
/// returns:
/// A <code>SpecificationEntry</code> object that contains information
/// about the requested spec entry, or <code>nil</code> if no entry was found.
- (SpecificationEntry * _Nullable)entryForLabel:(NSString * _Nonnull)label SWIFT_WARN_UNUSED_RESULT;
/// Adds the provided entry to the internal representation of the
/// specification. This does not modify the original spec document.
- (void)addEntry:(SpecificationEntry * _Nonnull)entry;
/// Deletes the given entry from the spec, without modifying the original spec
/// map.
/// \param entry The entry to remove.
///
- (void)removeEntry:(SpecificationEntry * _Nonnull)entry;
/// Initializes a blank specification entry that belongs to this spec.
///
/// returns:
/// The specification entry.
- (SpecificationEntry * _Nonnull)newEntry SWIFT_WARN_UNUSED_RESULT;
/// Determines the most relevant entry for the given body of text. Relevance is
/// computed in the same way as the search routines, using correspondence between
/// title, index string, and keywords weighted by the length of those words.
/// However, this search is “fuzzier” and ranks all entries by their relevance
/// to the query, so results will be returned even if there are no strongly-
/// matching entries in the spec. For a search that requires all query words to
/// be matched in the spec entry, use <code>searchEntries(with:options:)</code> instead.
/// \param queryText The text to search for in the spec. This may be a large body
/// of text, as this method does not search for complete matches.
///
/// \param resultCount The number of entries to return, provided the spec
/// contains at least this many entries.
///
///
/// returns:
/// The most similar entries, or an empty list if the spec has no entries.
- (NSArray<SpecificationEntry *> * _Nonnull)mostSimilarEntriesTo:(NSString * _Nonnull)queryText resultCount:(NSInteger)resultCount SWIFT_WARN_UNUSED_RESULT;
/// Generates a URL that can be inserted into attributed text as a link. The
/// URL can be resolved by calling <code>entry(for:)</code> with the URL string.
/// The format of the URL is the following: <code>spec://label/specID/revision</code>.
/// Subclasses may override this method to add additional components to the URL
/// <ul>
///   <li>
///     if doing so, they should also override <code>entry(for:)</code> to implement the
///     response to those URL changes.
///   </li>
/// </ul>
/// \param entry The entry to link to.
///
/// \param constrainSpecID If this is <code>true</code>, then only specs with the entry’s
/// spec identifier will match this link.
///
/// \param constrainSpecRevision If this is <code>true</code>, then only specs with the
/// same revision number as this entry’s spec will match the link.
///
///
/// returns:
/// A URL string for the entry.
- (NSString * _Nonnull)generateURLFor:(SpecificationEntry * _Nonnull)entry constrainSpecID:(BOOL)constrainSpecID constrainSpecRevision:(BOOL)constrainSpecRevision SWIFT_WARN_UNUSED_RESULT;
/// Loads the entries contained in the spec’s XML file. Entries are
/// automatically loaded when a lookup occurs, but you can call this method
/// early to pre-load a spec (for instance, if it is the primary spec you will
/// be using).
///
/// throws:
/// A specification error if the XML file is invalid or cannot be
/// parsed.
- (BOOL)loadStructureAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Writes the specification as an XML string. This method performs the exact
/// inverse of the <code>loadStructure</code> methods, and produces an XML string that can
/// be written to file and read back into a <code>Specification</code> object without
/// modification.
/// \param dtd The DTD to embed within the XML string, if desired.
///
///
/// throws:
/// This method throws an error if the DTD cannot be loaded.
///
/// returns:
/// A string containing the XML describing the spec.
- (NSString * _Nullable)writeSpecToXMLStringWithDtd:(NSURL * _Nullable)dtd error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Generates this specification’s auxiliary file requirements in XML format to
/// be added to the XML root element. The default implementation returns an
/// empty array.
///
/// returns:
/// The XML nodes for the auxiliary file requirements for this spec.
- (NSArray<NSXMLNode *> * _Nonnull)generateAuxiliaryFileRequirementXMLNodes SWIFT_WARN_UNUSED_RESULT;
/// Generates an XML element for the given entry. This method performs the
/// opposite of the <code>parseXMLEntry</code> method. To support additional attributes or
/// elements, subclasses should override this method, call <code>super</code> to obtain the
/// default keys and attributes, then add the custom elements.
/// \param entry The entry to convert into an XML element.
///
///
/// returns:
/// An XML element representing the entry.
- (NSXMLElement * _Nonnull)xmlElementFor:(SpecificationEntry * _Nonnull)entry SWIFT_WARN_UNUSED_RESULT;
/// Indicates whether all auxiliary file requirements for the specification are
/// satisfied.
@property (nonatomic, readonly) BOOL areFileRequirementsSatisfied;
/// Initializes a view controller containing the information in the entry
/// specified by <code>label</code>.
/// \param label A string identifying a unique entry in the spec.
///
///
/// returns:
/// A view controller object initialized with the entry requested.
/// If no entry was found or there was an error loading the view
/// controller, this method returns <code>nil</code>.
- (NSViewController * _Nullable)summaryViewControllerFor:(NSString * _Nonnull)label SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

@class PDFDocument;
@class PDFDestination;
@class PDFOutline;
@class PDFPage;
@class NSAttributedString;

SWIFT_CLASS("_TtC7SpecKit16PDFSpecification")
@interface PDFSpecification : Specification
/// The PDFKit document object that this specification will navigate.
@property (nonatomic, readonly, strong) PDFDocument * _Nullable document;
/// \code
/// The fileURL from which this specification's PDF was loaded.
///
/// \endcode
@property (nonatomic, copy) NSURL * _Nullable pdfURL;
/// The x-coordinate at which most lines in the PDF begin.
@property (nonatomic, readonly) CGFloat leftMargin;
/// The most prevalent text size in the document.
@property (nonatomic, readonly) CGFloat normalTextSize;
- (NSXMLElement * _Nonnull)xmlElementFor:(SpecificationEntry * _Nonnull)entry SWIFT_WARN_UNUSED_RESULT;
- (NSArray<NSXMLNode *> * _Nonnull)generateAuxiliaryFileRequirementXMLNodes SWIFT_WARN_UNUSED_RESULT;
/// Retrieves a destination in the specification PDF corresponding to the given
/// internal label.
/// \param label The internal label to search for in the PDF.
///
///
/// returns:
/// A <code>PDFDestination</code> object corresponding to the location of the
/// specified link label.
- (PDFDestination * _Nullable)destinationFor:(NSString * _Nonnull)label SWIFT_WARN_UNUSED_RESULT;
/// Determines the entry closest to the given destination in the PDF. If multiple
/// entries contain the destination, the entry with the smallest covered area
/// is returned (usually the figure or table).
/// \param destination The destination in the PDF document to search near.
///
///
/// returns:
/// The closest entry in the spec to the given destination, or <code>nil</code>
/// if none contain this point.
- (SpecificationEntry * _Nullable)closestEntryTo:(PDFDestination * _Nonnull)destination SWIFT_WARN_UNUSED_RESULT;
- (SpecificationEntry * _Nullable)entryForLabel:(NSString * _Nonnull)label SWIFT_WARN_UNUSED_RESULT;
/// Generates a URL that can be inserted into attributed text as a link. The
/// URL can be resolved by calling <code>entry(for:)</code> with the URL string.
/// The format of the URL is the following: <code>spec://label/specID/revision/line-start/line-end</code>.
/// \param entry The entry to link to.
///
/// \param constrainSpecID If this is <code>true</code>, then only specs with the entry’s
/// spec identifier will match this link.
///
/// \param constrainSpecRevision If this is <code>true</code>, then only specs with the
/// same revision number as this entry’s spec will match the link.
///
///
/// returns:
/// A URL string for the entry.
- (NSString * _Nonnull)generateURLFor:(SpecificationEntry * _Nonnull)entry constrainSpecID:(BOOL)constrainSpecID constrainSpecRevision:(BOOL)constrainSpecRevision SWIFT_WARN_UNUSED_RESULT;
/// Loads the internal mapping from section/article labels to destinations that
/// allows the specification object to navigate the PDF.
/// \param url The URL from which to load the document.
///
///
/// throws:
/// A <code>PDFSpecification.ParseError</code> if the method is unable to read the PDF
/// catalog hierarchy.
- (BOOL)loadPDFDocumentAtURL:(NSURL * _Nonnull)url error:(NSError * _Nullable * _Nullable)error;
/// Loads the internal mapping from section/article labels to destinations that
/// allows the specification object to navigate the PDF.
/// You should not call this method directly. Instead, use
/// <code>loadPDFDocument(at:)</code> so that the spec object can initialize
/// its own internal document type. However, subclasses that override this method
/// must call <code>super</code>.
/// \param document A PDFKit document object belonging to the specification.
///
///
/// throws:
/// A <code>PDFSpecification.ParseError</code> if the method is unable to read the PDF
/// catalog hierarchy.
- (BOOL)loadPDFStructureFromDocument:(PDFDocument * _Nonnull)document error:(NSError * _Nullable * _Nullable)error;
/// A mapping between section labels (such as their titles in the
/// document) and their corresponding outline items, each of which points to
/// a destination in the PDF.
@property (nonatomic, copy) NSDictionary<NSString *, PDFOutline *> * _Nonnull documentOutline;
/// Provides an internal link that can be used in the XML spec map for a
/// destination contained in an outline item.
/// \param outlineItem The outline item whose destination this link should point
/// to.
///
///
/// returns:
/// The internal link for the outline.
- (NSString * _Nonnull)internalLinkForOutline:(PDFOutline * _Nonnull)outlineItem SWIFT_WARN_UNUSED_RESULT;
/// Provides an internal link that can be used in the XML spec map for an
/// arbitrary destination point in the PDF.
/// \param destination The destination to refer to.
///
///
/// returns:
/// The internal link for the destination.
- (NSString * _Nonnull)internalLinkFor:(PDFDestination * _Nonnull)destination SWIFT_WARN_UNUSED_RESULT;
/// Provides an internal link that can be used in the XML spec map for an
/// arbitrary set of rectangles in the PDF. This allows you to define entries
/// that would not be generated correctly using the standard PDF heuristics.
/// \param pageRects A dictionary of page numbers and the rectangles for the
/// entry on those pages.
///
///
/// returns:
/// The internal link for the destination rectangles.
- (NSString * _Nonnull)internalLinkForRectangles:(NSDictionary<NSNumber *, NSValue *> * _Nonnull)pageRects SWIFT_WARN_UNUSED_RESULT;
/// Indicates whether the given line rect is part of a layout break on the page.
/// Subclasses may override this method to change the behavior of the layout-
/// break detection methods for identifying figures and tables.
/// \param lineOrigin A rectangle containing text (usually a single character)
/// that could be part of a layout break.
///
/// \param page The page on which the rectangle lies.
///
///
/// returns:
/// A Boolean value indicating whether the line origin is the start
/// of a layout break.
- (BOOL)isLine:(NSRect)lineOrigin partOfLayoutBreakOn:(PDFPage * _Nonnull)page SWIFT_WARN_UNUSED_RESULT;
/// Indicates whether the given line rect starts the given layout-breaking
/// entry. This method should detect the geometry of the figure/table heading
/// as well as the text of the line to be most accurate about where the entry
/// starts. Subclasses may override this method to support different PDF heading
/// styles.
/// \param lineOrigin A rectangle containing text (usually a single character)
/// that could be part of a layout break.
///
/// \param line The text of the entire line.
///
/// \param entry The entry that the layout break would represent.
///
/// \param page The page on which the rectangle lies.
///
///
/// returns:
/// A Boolean value indicating whether the line origin is the start
/// of a layout break for the given entry.
- (BOOL)isLine:(NSRect)lineOrigin :(NSString * _Nonnull)line startOfLayoutBreakFor:(SpecificationEntry * _Nonnull)entry on:(PDFPage * _Nonnull)page SWIFT_WARN_UNUSED_RESULT;
/// Indicates whether the given text is styled appropriately to be a heading.
/// The default implementation detects the “normal” text size of the document,
/// and returns whether the given text is larger or stylized (bold or italic).
/// Subclasses may override this method to include heuristics for different PDF
/// styles.
/// \param text The attributed text that could be a heading.
///
/// \param lineBounds The rectangle that this line occupies.
///
/// \param page The page in the PDF document on which the text was found.
///
///
/// returns:
/// Whether the text should be considered a heading.
- (BOOL)isTextHeading:(NSAttributedString * _Nonnull)text at:(NSRect)lineBounds on:(PDFPage * _Nonnull)page SWIFT_WARN_UNUSED_RESULT;
/// Indicates whether the given line of text should be included in the extracted
/// text for the entry. The default implementation compares the line to the
/// actual entry title, and opts to include the text if it contains more than a
/// certain amount over the title length.
/// \param headingLine The entire line of text that contains the entry title.
///
/// \param entry The entry for which this text is being extracted.
///
///
/// returns:
/// Whether the text should be included in the summary text for the
/// entry.
- (BOOL)shouldIncludeHeadingLine:(NSString * _Nonnull)headingLine inExtractedTextFor:(SpecificationEntry * _Nonnull)entry SWIFT_WARN_UNUSED_RESULT;
/// Formats the given attributed text for summary text purposes. This text is not
/// guaranteed to match the summary text for any given entry, as it is called
/// before the final set of ranges is assembled.
/// <em>Important:</em> This method must not modify the position or length of any
/// text in the attributed string. <code>PDFSpecification</code> tracks the display ranges that
/// correspond to each range from the PDF, so modifying the ranges here would
/// cause unwanted consequences for entry selection.
/// \param text The attributed text to format.
///
- (void)preformatPDFText:(NSMutableAttributedString * _Nonnull)text;
/// Computes the left margin that is used most often on the page, relative to
/// the specified display box.
/// \param document The document to analyze.
///
/// \param displayBox The PDF display box used as the reference for the returned
/// value.
///
///
/// returns:
/// The offset from the x-origin of the specified box at which most
/// lines on the document start.
- (CGFloat)computeLeftMarginFor:(PDFDocument * _Nonnull)document in:(PDFDisplayBox)displayBox interval:(NSInteger)interval SWIFT_WARN_UNUSED_RESULT;
/// Computes the text size that is used most often in the document by sampling
/// a small number of pages and counting the text sizes used.
/// \param document The document to analyze.
///
/// \param interval The modulus to use for deciding which pages to analyze. The
/// default value is 100, meaning that pages 1, 101, 201, 301, … will
/// be checked.
///
///
/// returns:
/// The most common text size in the document, in points.
- (CGFloat)computeNormalTextSizeFor:(PDFDocument * _Nonnull)document interval:(NSInteger)interval SWIFT_WARN_UNUSED_RESULT;
/// Removes unnecessary whitespace/newlines for one-character lines and adds
/// newlines at the end of the string for paragraph-type text. This improves
/// the readability of the line.
/// Subclasses may override this method and call <code>super</code> to implement additional
/// formatting changes if desired.
/// \param line An untrimmed line.
///
///
/// returns:
/// The same line of text, properly formatted with trailing newlines
/// and trimmed whitespace as appropriate.
- (NSAttributedString * _Nonnull)formattedLine:(NSAttributedString * _Nonnull)line SWIFT_WARN_UNUSED_RESULT;
@end


/// <code>PDFXMLEnhancer</code> allows you to enhance spec XML maps to include internal links
/// from a PDF, as well as performing text processing on the PDF to extract
/// keywords and related entries.
/// To use <code>PDFXMLEnhancer</code>, initialize it with an XML structure file
/// and a PDF, then call <code>loadStructure()</code>. The information will be added to this
/// spec object’s entries, which can be then written to file using the standard
/// Specification methods.
SWIFT_CLASS("_TtC7SpecKit14PDFXMLEnhancer")
@interface PDFXMLEnhancer : PDFSpecification
/// The markers that will cause an internal link to be ignored.
@property (nonatomic, copy) NSArray<NSString *> * _Nonnull ignoreLinkMarkers;
/// The markers whose absence will cause an internal link to be ignored.
@property (nonatomic, copy) NSArray<NSString *> * _Nonnull requiredLinkMarkers;
/// Initializes a link matcher spec object. Call <code>loadStructure</code> to perform the
/// XML enhancements.
/// \param xmlMap The URL to the XML file to parse.
///
/// \param pdf The URL for the PDF whose internal links are desired.
///
///
/// throws:
/// An XML error if there was a problem reading the spec map.
- (nullable instancetype)initWithStructureFileAt:(NSURL * _Nonnull)xmlMap matchedWith:(NSURL * _Nonnull)pdf error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// This method loads and validates the spec’s given XML file, then iterates
/// over all entries in the spec and finds the corresponding internal links for
/// those sections in the PDF. The method adds this data to the internal
/// representation of the spec, which can then be written to an XML file using
/// the standard Specification API.
- (BOOL)loadStructureAndReturnError:(NSError * _Nullable * _Nullable)error;
/// This override is used to collect the internal links in isolation, perform
/// the pairing process, and set the relevant properties on the entries so that
/// the data can be written to file using the Specification API.
- (BOOL)loadPDFStructureFromDocument:(PDFDocument * _Nonnull)document error:(NSError * _Nullable * _Nullable)error;
/// The main procedure for link matching, this method iterates over all entries
/// in the spec map and identifies them with named destinations in the PDF. The
/// results are stored in the <code>labelLinkMapping</code> property.
/// The method makes the assumption that the internal links map one-to-one with
/// the entries in the XML file. Furthermore, internal links will be marked with
/// a string identifying their type; for instance, figure links contain “FLK”,
/// table links contain “TLK”, etc. Links that contain the words “TOC”,
/// “TITLEPAGE”, or “LOFAT” will be ignored, as will links that do not contain
/// the word “apple_ref”.
/// \param document The PDF document from which to read text for the purposes of
/// identifying entries.
///
///
/// returns:
/// A mapping of human-readable labels (keys) to destination links in
/// the document (values).
- (NSDictionary<NSString *, NSString *> * _Nonnull)pairHumanReadableLabelsWithInternalLinksFrom:(PDFDocument * _Nonnull)document SWIFT_WARN_UNUSED_RESULT;
/// The weight to be applied to keywords that occur in parent and child entry
/// titles.
@property (nonatomic) double associatedEntryTitleWeight;
/// The maximum number of keywords to generate for each entry.
@property (nonatomic) NSInteger maxKeywordCount;
/// The weight to apply to relationships between entries based on common words
/// in their titles.
@property (nonatomic) double relatedEntryTitleWeight;
/// The weight to apply to relationships between entries based on common
/// keywords.
@property (nonatomic) double relatedEntryKeywordWeight;
/// The weight to apply to a relation from node X to node Y when X contains a
/// link to Y.
@property (nonatomic) double relatedEntryLinkedWeight;
/// The weight to apply to a relation from node X to node Y when Y contains a
/// link to X.
@property (nonatomic) double relatedEntryLinkingWeight;
/// The weight to apply to a relation from figure/table X to node Y when Y is
/// the closest textual entry to X.
@property (nonatomic) double relatedEntryFigureAssociationWeight;
/// The maximum number of related entries to add for any entry.
@property (nonatomic) NSInteger maxRelatedEntryCount;
/// The fraction of entry relationships to prune after NLP analysis. For instance,
/// if the value is 0.25, then the top 75% strongest relationships will be
/// preserved.
@property (nonatomic) double relatedEntryPruningFraction;
@end


/// <code>PDFDestinationApproximator</code> generates spec XML maps for PDF documents which do
/// not contain internal links. This class requires the PDF to contain an embedded
/// outline, which will be used to determine the destinations for TOC items. Figures
/// and tables are located using the standard layout-breaking entry pattern (entries
/// whose text deviates from the normal left margin of the document).
/// To use <code>PDFDestinationApproximator</code>, initialize it with an XML structure file
/// and a PDF, then call <code>loadStructure()</code>. The information will be added to this
/// spec object’s entries, which can be then written to file using the standard
/// Specification methods.
SWIFT_CLASS("_TtC7SpecKit26PDFDestinationApproximator")
@interface PDFDestinationApproximator : PDFXMLEnhancer
- (BOOL)loadPDFStructureFromDocument:(PDFDocument * _Nonnull)document error:(NSError * _Nullable * _Nullable)error;
/// This override leverages the information in the outline as well as the layout-
/// breaking regions of the PDF document to infer the locations of figures and
/// tables.
- (NSDictionary<NSString *, NSString *> * _Nonnull)pairHumanReadableLabelsWithInternalLinksFrom:(PDFDocument * _Nonnull)document SWIFT_WARN_UNUSED_RESULT;
- (nullable instancetype)initWithStructureFileAt:(NSURL * _Nonnull)xmlMap matchedWith:(NSURL * _Nonnull)pdf error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
@end






/// <code>PDFSpecAuditor</code> creates human-readable representations of spec entries to
/// audit their contents.
/// To use <code>PDFSpecAuditor</code>, initialize a new auditor with the <code>init(spec:)</code> method,
/// then call the audit method that produces the desired format. For CSV, you can
/// optionally prefix each audit entry with custom fields.
SWIFT_CLASS("_TtC7SpecKit14PDFSpecAuditor")
@interface PDFSpecAuditor : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end



@class NSTableColumn;
@class NSView;

/// <code>SpecAuditBrowserController</code> allows you to quickly audit the spec references in
/// your application. You can initialize it with all labels that your application
/// refers to, optionally supplementing that information with custom components,
/// then display it in a window and browse through it to identify incorrect
/// references.
SWIFT_CLASS("_TtC7SpecKit26SpecAuditBrowserController")
@interface SpecAuditBrowserController : NSViewController <NSTableViewDataSource, NSTableViewDelegate, NSWindowDelegate>
/// Initializes a spec audit browser with the given parameters. The entries will
/// be loaded asynchronously when the view is displayed.
/// \param labels The labels for the entries to display.
///
/// \param spec The spec in which to search for the labels.
///
/// \param customHeadings The headings for the custom items to be displayed
/// alongside each entry.
///
/// \param customComponents The items to be displayed before each entry. Each
/// list within this list must have the same number of objects as
/// <code>customHeadings</code>.
///
- (nullable instancetype)initWithLabels:(NSArray<NSString *> * _Nonnull)labels in:(PDFSpecification * _Nonnull)spec customHeadings:(NSArray<NSString *> * _Nullable)customHeadings customComponents:(NSArray<NSArray<NSString *> *> * _Nullable)customComponents OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (void)viewDidLoad;
- (void)viewWillAppear;
- (void)viewDidAppear;
- (NSView * _Nullable)tableView:(NSTableView * _Nonnull)tableView viewForTableColumn:(NSTableColumn * _Nullable)tableColumn row:(NSInteger)row SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithNibName:(NSNibName _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end


/// <code>SpecEntrySelectionViewController</code> provides an interface allowing users to
/// browse through their loaded specifications and select an entry for use in your
/// application. The UI is best presented as a modal sheet; the status code of the
/// sheet when it ends indicates whether the user selected an entry or not. If the
/// user did select an entry, the <code>selectedEntry</code> property provides you with that
/// information.
/// <em>Note:</em> Users can select entries in specific specs and down to the paragraph
/// level, so the <code>label</code> property of the spec entry may not be sufficient to
/// describe the user’s selection. Instead, use the <code>generateURL(for:)</code> method on
/// <code>Specification</code> to produce a spec URL string that will recover the exact
/// selection.
/// Specs are displayed using the standard detail view controllers that they provide,
/// so if you create a custom spec with a custom detail view controller, that will
/// be displayed here automatically when the file requirements for the custom spec
/// are satisfied.
SWIFT_CLASS("_TtC7SpecKit32SpecEntrySelectionViewController")
@interface SpecEntrySelectionViewController : NSViewController
/// The currently highlighted entry in the selection browser.
@property (nonatomic, strong) SpecificationEntry * _Nullable selectedEntry;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (void)viewDidLoad;
- (nonnull instancetype)initWithNibName:(NSNibName _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end


/// View controller that displays summary information about its entry.
SWIFT_CLASS("_TtC7SpecKit30SpecEntrySummaryViewController")
@interface SpecEntrySummaryViewController : NSViewController <NSTableViewDataSource, NSTableViewDelegate>
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
- (void)viewDidLoad;
- (NSInteger)numberOfRowsInTableView:(NSTableView * _Nonnull)tableView SWIFT_WARN_UNUSED_RESULT;
- (NSView * _Nullable)tableView:(NSTableView * _Nonnull)tableView viewForTableColumn:(NSTableColumn * _Nullable)tableColumn row:(NSInteger)row SWIFT_WARN_UNUSED_RESULT;
- (CGFloat)tableView:(NSTableView * _Nonnull)tableView heightOfRow:(NSInteger)row SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithNibName:(NSNibName _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end

@class NSTokenField;
@class NSMenu;
@class NSPopover;

/// <code>SpecEntryTokenFieldDelegate</code> provides pre-configured helper tools to easily
/// create a token field for searching through a spec’s entries. When creating such
/// a token field, simply configure the field with the desired appearance, then set
/// the token field’s delegate to a new <code>SpecEntryTokenFieldDelegate</code> initialized
/// with token field and spec parameters. Be sure to store a strong reference to
/// this delegate object, as the token field stores only a weak reference.
/// The token field delegate modifies the token field’s object value programmatically,
/// so bindings will not be updated properly. Be sure to set the token field’s
/// action method to catch the updated values.
/// <code>SpecEntryTokenFieldDelegate</code> overrides the following token field delegate
/// methods:
/// <ul>
///   <li>
///     <code>tokenField(_:completionsForSubstring:indexOfToken:indexOfSelectedItem:)</code>
///   </li>
///   <li>
///     <code>tokenField(_:representedObjectForEditing:)</code>
///   </li>
///   <li>
///     <code>tokenField(_:displayStringForRepresentedObject:)</code>
///   </li>
///   <li>
///     <code>tokenField(_:editingStringForRepresentedObject:)</code>
///   </li>
///   <li>
///     <code>tokenField(_:hasMenuForRepresentedObject:)</code>
///   </li>
///   <li>
///     <code>tokenField(_:menuForRepresentedObject:)</code>
///   </li>
/// </ul>
/// If you subclass <code>SpecEntryTokenFieldDelegate</code>, be sure not to call <code>super</code> on
/// any delegate method <em>not</em> listed above.
SWIFT_CLASS("_TtC7SpecKit27SpecEntryTokenFieldDelegate")
@interface SpecEntryTokenFieldDelegate : NSObject <NSPopoverDelegate, NSTokenFieldDelegate>
/// The token field that this delegate object responds to.
@property (nonatomic, readonly, strong) IBOutlet NSTokenField * _Null_unspecified tokenField;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
/// Displays a spec entry browser sheet that allows the user to select a new
/// entry, then inserts that entry into the token field.
- (IBAction)insertTokenFromSpecEntryBrowser:(id _Nonnull)sender;
- (NSArray * _Nullable)tokenField:(NSTokenField * _Nonnull)tokenField completionsForSubstring:(NSString * _Nonnull)substring indexOfToken:(NSInteger)tokenIndex indexOfSelectedItem:(NSInteger * _Nullable)selectedIndex SWIFT_WARN_UNUSED_RESULT;
- (id _Nullable)tokenField:(NSTokenField * _Nonnull)tokenField representedObjectForEditingString:(NSString * _Nonnull)editingString SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nullable)tokenField:(NSTokenField * _Nonnull)tokenField displayStringForRepresentedObject:(id _Nonnull)representedObject SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nullable)tokenField:(NSTokenField * _Nonnull)tokenField editingStringForRepresentedObject:(id _Nonnull)representedObject SWIFT_WARN_UNUSED_RESULT;
- (BOOL)tokenField:(NSTokenField * _Nonnull)tokenField hasMenuForRepresentedObject:(id _Nonnull)representedObject SWIFT_WARN_UNUSED_RESULT;
- (NSMenu * _Nullable)tokenField:(NSTokenField * _Nonnull)tokenField menuForRepresentedObject:(id _Nonnull)representedObject SWIFT_WARN_UNUSED_RESULT;
- (BOOL)popoverShouldDetach:(NSPopover * _Nonnull)popover SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_CLASS("_TtC7SpecKit16SpecKitConstants")
@interface SpecKitConstants : NSObject
+ (NSString * _Nonnull)SpecManagerAuxiliaryFilesChangedNotification SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



@interface Specification (SWIFT_EXTENSION(SpecKit))
/// Adds the given spec class type to the <code>Specification</code> factory registry. This
/// is suitable for telling the factory about a spec subclass that can handle a
/// new type of auxiliary file. For instance, if you create a subclass that
/// handles RTF specs, you could register the new spec type by passing in a
/// predicate that checks if the auxiliary file requirement specifies an RTF
/// file.
/// This predicate will be used in the constructor
/// <code>Specification.withStructureFile(at:dtd:)</code>, allowing you to integrate the
/// subclass uniformly with SpecKit’s standard UI.
/// <em>Note:</em> You must call this method before initializing any specs (e.g. by
/// using the <code>SpecificationManager</code> loading methods).
/// \param specType The spec class type of which an instance should be initialized
/// if a given spec map satisfies the predicate.
///
/// \param prioritize Indicates whether to place the spec definition at the head
/// or tail of the predicates list. By default, this definition will be
/// run after all others fail.
///
/// \param predicate A block that indicates whether the given spec type will
/// support the provided spec map.
///
/// \param spec A prototype spec containing metadata about the spec map. You can
/// use this object to request information about the spec’s identifier,
/// auxiliary file requirements, etc.
///
+ (void)registerSpecType:(SWIFT_METATYPE(Specification) _Nonnull)specType prioritize:(BOOL)prioritize where:(BOOL (^ _Nonnull)(Specification * _Nonnull))predicate;
/// Class constructor that validates the provided XML structure file using
/// either a DTD within the XML file or a DTD file at a URL you provide. It
/// then inspects its auxiliary file requirements, and returns a <code>Specification</code>
/// object appropriate for handling that data.
/// \param url - A file URL pointing to an XML structure file.
///
/// \param dtd - An optional file URL pointing to the DTD that corresponds
/// to the structure file. If you do not pass this parameter, the XML
/// structure file must contain a DTD.
///
///
/// returns:
/// A <code>Specification</code> object initialized with the XML document.
/// Depending on the auxiliary file requirements (see
/// <code>Specification.auxiliaryFileRequirements</code>), you may need to supply
/// appropriate auxiliary files.
+ (Specification * _Nullable)withStructureFileAt:(NSURL * _Nonnull)url dtd:(NSURL * _Nullable)dtd error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_CLASS("_TtC7SpecKit23SpecificationComparator")
@interface SpecificationComparator : NSObject
- (nonnull instancetype)initWithComparator:(NSComparisonResult (^ _Nonnull)(Specification * _Nonnull, Specification * _Nonnull))comparator OBJC_DESIGNATED_INITIALIZER;
+ (SpecificationComparator * _Nonnull)comparatorWithBlock:(NSComparisonResult (^ _Nonnull)(Specification * _Nonnull, Specification * _Nonnull))block SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

enum SpecificationEntryType : NSInteger;

/// A protocol that defines the basic information about an entry,
/// such as a chapter or figure, in a specification. Instances that conform
/// to this protocol have a <code>dict</code> property which allows you to enumerate
/// their attributes.
SWIFT_CLASS("_TtC7SpecKit18SpecificationEntry")
@interface SpecificationEntry : NSObject <NSCopying>
/// The title of the entry, such as “iPhone 7 Case Testing Matrix” or “Audio
/// Routing”.
@property (nonatomic, copy) NSString * _Nonnull title;
/// The path to the entry in a table of contents; for instance, [2, 4, 20]
/// would define section 2.4.20.
@property (nonatomic, copy) NSArray<NSNumber *> * _Nonnull index;
/// The internal label by which this entry can be accessed. Usually of the form
/// chapter:section:subsection.
@property (nonatomic, copy) NSString * _Nonnull label;
/// The type of the entry, such as a section or figure.
@property (nonatomic) enum SpecificationEntryType type;
/// Words that describe the content of this entry. These keywords may be
/// multiple words if a phrase appears to be relevant to the entry’s meaning.
@property (nonatomic, copy) NSArray<NSString *> * _Nonnull keywords;
/// Links to similar entries that the user should be directed to browse to learn
/// more about this entry’s topic.
@property (nonatomic, copy) NSArray<NSString *> * _Nonnull relatedEntries;
/// The specification from which this entry originates.
@property (nonatomic, weak) Specification * _Nullable specification;
/// The title to be used for display purposes, summarizing the entry.
@property (nonatomic, readonly, copy) NSString * _Nonnull displayTitle;
@property (nonatomic, readonly, copy) NSString * _Nonnull indexSeparator;
/// Initializes a specification entry belonging to the given spec.
- (nonnull instancetype)initWithSpec:(Specification * _Nullable)spec OBJC_DESIGNATED_INITIALIZER;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


@interface SpecificationEntry (SWIFT_EXTENSION(SpecKit))
@property (nonatomic, readonly, copy) NSArray<ObjCEntryDisplayItem *> * _Nonnull objCDisplayItems;
@end

/// Enumerates the possible types of specification entries supported by SpecKit.
typedef SWIFT_ENUM(NSInteger, SpecificationEntryType, closed) {
/// \code
/// A smaller section of the spec, such as 19.3.4 Certification Requirements.
///
/// \endcode
  SpecificationEntryTypeSection = 0,
/// \code
/// A chapter of the spec, such as 19. AirPlay.
///
/// \endcode
  SpecificationEntryTypeChapter = 1,
/// \code
/// A numbered figure within the spec, such as an image or schematic.
///
/// \endcode
  SpecificationEntryTypeFigure = 2,
/// \code
/// A numbered table within the spec.
///
/// \endcode
  SpecificationEntryTypeTable = 3,
};


/// A <code>SpecificationManager</code> instance maintains several instances of <code>Specification</code>
/// and provides the means to query those specifications for article labels. The
/// manager provides SpecKit view controllers that are ready to be displayed, showing
/// appropriate information from the spec based on the query.
SWIFT_CLASS("_TtC7SpecKit20SpecificationManager")
@interface SpecificationManager : NSObject
/// The list of specifications loaded by the manager.
@property (nonatomic, readonly, copy) NSArray<Specification *> * _Nonnull specifications;
/// The specification that should be primarily used for lookups. For instance,
/// if the client is built on an older version of a spec while newer versions
/// are supported to a lesser extent, this property should be set to the older
/// spec.
/// <em>Note:</em> You should not store the primary specification yourself, as it
/// may change values as auxiliary file statuses change. Instead, set the
/// <code>primarySpecificationPredicate</code> property when you first initialize the
/// <code>SpecificationManager</code>, then access the <code>primarySpecification</code> property
/// when you need it.
@property (nonatomic, readonly, strong) Specification * _Nullable primarySpecification;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) SpecificationManager * _Nonnull shared;)
+ (SpecificationManager * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// Adds a specification to the manager’s list of specifications.
/// \param spec The specification to add.
///
- (void)registerSpec:(Specification * _Nonnull)spec;
/// Loads a specification from the XML file at <code>url</code> (and the optional <code>dtd</code>
/// parameter) and adds it to the manager’s list of specifications.
/// \param url The URL pointing to the XML file from which the structure of the
/// specification should be loaded.
///
/// \param dtd A document type definition file that should be used to validate
/// the XML.
///
///
/// throws:
/// A file manager error or <code>Specification.XMLError</code> if the XML was
/// not found or invalid.
- (BOOL)registerSpecWithURL:(NSURL * _Nonnull)url DTD:(NSURL * _Nullable)dtd error:(NSError * _Nullable * _Nullable)error;
/// Loads all files with a .xml file extension as specifications
/// into the specification manager.
/// \param directory A URL pointing to the directory in which the specification
/// manager should search.
/// Per the requirements of <code>Specification</code> parsing, every XML file must
/// either have an embedded document type definition (DTD) or an external
/// DTD file. This method searches for a DTD with the same name as the
/// corresponding XML file but with a “.dtd” file extension. To use a
/// different DTD path, use the more fine-grained method
/// <code>register(specWithURL:_,dtd:_)</code>.
///
/// \param auxiliaryFiles A list of URLs pointing to files that supplement the
/// XML structure, such as PDFs. Each file must correspond to a loaded
/// specification.
///
///
/// throws:
/// A <code>FileManager</code> error if there was an error fetching the files,
/// or a SpecKit error if an error occurred while parsing the XML or
/// if a user-provided file was unable to be assigned.
- (BOOL)loadSpecInformationFromDirectory:(NSURL * _Nonnull)directory auxiliaryFiles:(NSArray<NSURL *> * _Nonnull)auxiliaryFiles error:(NSError * _Nullable * _Nullable)error;
/// A closure that allows the specification manager to select its primary spec
/// for lookups. You should not store the primary specification yourself, as it
/// may change values as auxiliary file statuses change. Instead, set the
/// predicate when you first initialize the <code>SpecificationManager</code>, then access
/// the <code>primarySpecification</code> property when you need it.
@property (nonatomic, copy) BOOL (^ _Nullable primarySpecificationPredicate)(Specification * _Nonnull);
/// The list of auxiliary files that have been registered to specifications by
/// this manager.
@property (nonatomic, copy) NSArray<NSURL *> * _Nonnull auxiliaryFiles;
/// Assigns an auxiliary file to a specification. The file must correspond to a
/// specification that has already been registered with the manager object and
/// loaded from an XML structure file.
/// <ul>
///   <li>
///     Parameters:
///   </li>
/// </ul>
/// <ul>
///   <li>
///     url: The URL pointing to the auxiliary file.
///   </li>
/// </ul>
///
/// throws:
/// A <code>SpecificationManager.SetupError</code> if the file could not be assigned
/// to a specification, or a more specific specification error if there
/// was a problem parsing the auxiliary file.
///
/// returns:
/// The URL which was registered as an auxiliary file. This may point
/// to SpecKit’s local storage of the auxiliary file, or the original file.
- (NSURL * _Nullable)registerAuxiliaryFileAtURL:(NSURL * _Nonnull)url error:(NSError * _Nullable * _Nullable)error;
/// Assigns a list of auxiliary files to specifications. Every file must
/// correspond to a specification that has already been registered with the
/// manager object and loaded from an XML structure file.
/// <ul>
///   <li>
///     Parameters:
///   </li>
/// </ul>
/// <ul>
///   <li>
///     urls: The URLs pointing to the auxiliary files.
///   </li>
/// </ul>
///
/// throws:
/// A <code>SpecificationManagerError</code> if any file could not be assigned
/// to a specification.
- (BOOL)registerAuxiliaryFilesAtURLs:(NSArray<NSURL *> * _Nonnull)urls error:(NSError * _Nullable * _Nullable)error;
/// Removes the auxiliary file from the registered list, from the directory and resets any
/// specifications which utilize the file.
/// \param url The URL for the file to remove.
///
- (void)unregisterAuxiliaryFileAtURL:(NSURL * _Nonnull)url;
/// Initializes a new auxiliary file browser controller, suitable for display
/// in a preferences pane.
///
/// returns:
/// The new browser controller.
- (NSViewController * _Nonnull)auxiliaryFileBrowser SWIFT_WARN_UNUSED_RESULT;
/// Code that will be executed when the spec manager wants to display the
/// auxiliary file browser. For instance, if the user attempts to look up an
/// entry before loading any specs, they will be prompted to import them. This
/// block should present the auxiliary file browser given any window
/// configuration; therefore, it may be practical to set this closure in the
/// app delegate. The browser would be optimally placed in a preferences pane
/// or other universal configuration view.
/// This block is not guaranteed to pass an <code>AuxiliaryFileBrowserController</code>
/// instance, but you may conditionally cast the parameter to this block as
/// <code>AuxiliaryFileBrowserController</code> and set a custom accessory view if the
/// cast succeeds.
/// <em>Note:</em> The closure should not hold a strong reference to <code>self</code>, as it will
/// be kept alive as long as the spec manager is active.
/// \param browser The browser controller to display.
///
@property (nonatomic, copy) void (^ _Nullable auxiliaryFileBrowserDisplayBlock)(NSViewController * _Nonnull);
/// Indicates whether or not the spec manager can display the auxiliary file
/// browser. This would be <code>false</code> if the <code>auxiliaryFileBrowserDisplayBlock</code>
/// property has not been set.
@property (nonatomic, readonly) BOOL canDisplayAuxiliaryFileBrowser;
/// Displays the auxiliary file browser using the <code>auxiliaryFileBrowserDisplayBlock</code>
/// closure set by the client.
- (void)showAuxiliaryFileBrowser;
/// Code that will be executed when a client wants to display a detail view
/// controller for a spec entry. This allows the client app to loosely couple
/// the code that creates a spec reference detail window from the code that
/// requests a detail view; for instance, if the app delegate handles opening a
/// detail window, code within other app classes that requests detail information
/// does not need to know that behavior. All those classes have to do is call
/// <code>showDetailViewController(for:)</code> on the spec manager.
/// The closure takes one parameter: a spec detail view controller to display.
/// This parameter may be <code>nil</code>, in which case the closure should bring the
/// existing detail view controller to front.
@property (nonatomic, copy) void (^ _Nullable detailViewControllerDisplayBlock)(NSViewController * _Nonnull);
/// Convenience method that returns a spec satisfying the requirements of a
/// predicate. For example, one could use this method to query the manager for
/// an AI Specification with revision number 25.
/// \param predicate A closure that takes a specification object and returns a
/// Boolean value indicating whether the spec should be returned.
///
///
/// returns:
/// The first specification object that satisfies the predicate,
/// or <code>nil</code> if no such spec was found among the loaded specs.
- (Specification * _Nullable)specificationPassingTest:(SWIFT_NOESCAPE BOOL (^ _Nonnull)(Specification * _Nonnull))predicate SWIFT_WARN_UNUSED_RESULT;
/// Performs a lookup in the specification for <code>label</code>, and returns an entry
/// whose <code>displayItems</code> property can be used to display information about the
/// entry in a custom UI. This method looks first in the designated primary
/// specification, then iterates over all available specifications to find the
/// label.
/// \param label The unique identifying label for the entry desired.
///
/// \param predicate An optional closure that determines whether or not a spec
/// should be searched for this entry. The closure takes a single
/// parameter, the specification to be validated.
///
///
/// returns:
/// An entry that has the given label, or <code>nil</code> if none was found
/// in any of the loaded specifications.
- (SpecificationEntry * _Nullable)entryForLabel:(NSString * _Nonnull)label inSpecsPassingTest:(SWIFT_NOESCAPE BOOL (^ _Nonnull)(Specification * _Nonnull))predicate SWIFT_WARN_UNUSED_RESULT;
/// Performs a lookup in the specification for <code>label</code>, and returns a view
/// controller appropriate for displaying the information in an abbreviated
/// format.
/// \param label The unique identifying label for the entry desired.
///
/// \param predicate An optional closure that determines whether or not a spec
/// should be searched for this entry. The closure takes a single
/// parameter, the specification to be validated.
///
///
/// returns:
/// A view controller that displays the summary information for
/// the entry defined by <code>label</code>. If the entry was found in a loaded spec, this
/// method returns a <code>SpecEntrySummaryViewController</code> that you may configure
/// with additional display items if desired. If the entry was not found, the
/// view controller returned will be of another type and display an error view.
- (NSViewController * _Nonnull)summaryLookupForLabel:(NSString * _Nonnull)label inSpecsPassingTest:(SWIFT_NOESCAPE BOOL (^ _Nonnull)(Specification * _Nonnull))predicate SWIFT_WARN_UNUSED_RESULT;
/// Performs a lookup in the specifications for <code>label</code>, initializes a view
/// controller suitable for displaying detailed information about the spec entry,
/// and requests that the entry be displayed using the
/// <code>detailViewControllerDisplayBlock</code>.
/// \param label The unique identifying label for the entry desired.
///
/// \param predicate An optional closure that determines whether or not a spec
/// should be searched for this entry. The closure takes a single
/// parameter, the specification to be validated.
///
- (void)showDetailViewControllerForLabel:(NSString * _Nonnull)label inSpecsPassingTest:(SWIFT_NOESCAPE BOOL (^ _Nonnull)(Specification * _Nonnull))predicate;
/// Returns information about the provided spec entry in a format
/// appropriate for a detail view.
/// \param entry The specification entry for which you want detailed information.
///
///
/// returns:
///
/// A view controller that displays detailed information for <code>entry</code>.
/// Returns <code>nil</code> if the label is not found in any specification.
- (NSViewController * _Nullable)detailLookupForEntry:(SpecificationEntry * _Nonnull)entry SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


@interface SpecificationManager (SWIFT_EXTENSION(SpecKit))
@property (nonatomic, copy) NSArray<SpecificationComparator *> * _Nonnull objcSpecComparators;
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
