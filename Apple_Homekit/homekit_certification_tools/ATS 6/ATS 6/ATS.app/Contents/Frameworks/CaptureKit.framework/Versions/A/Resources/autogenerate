#!/usr/bin/env ruby
require 'open3'
require 'yaml'
require 'tmpdir'
require 'fileutils'


def run(command, dir=nil)
    puts "\nRunning: \`#{command}\` in #{dir || `pwd`}"
    result_string = ""
    Open3.popen2e('bash') do |stdin, stdout_and_stderr, wait_thr|
    stdin.write("cd #{dir}\n") if dir
    stdin.write(command)
    stdin.close

    while line = stdout_and_stderr.gets
        puts line if line[-1] != "\r"
        if (result_string.length < 1024)
            result_string << line
        end
    end
    if wait_thr.value != 0
        raise "Non-zero return value!"
    end
    puts "Finished running #{command}"
    end
    return result_string
end

def autoGenerateSource(project_dir, input_dir, output_dir)
    variant = (ENV['APPLE_INTERNAL'] && (ENV['APPLE_INTERNAL'] == 1 || ENV['APPLE_INTERNAL'] == "YES")) ? 'internal' : 'external'
    internal = (variant == 'internal')
    internal_boolean_string = internal ? 'YES' : 'NO'
    puts "Generating #{variant} variant"
    
    ### LKTSpecDefs ###
    lktspec_file = "#{output_dir}/Default.lktspec"
    rtconstants_file = "#{output_dir}/RTConstants.h"
    iapconstants_file = "#{output_dir}/iAPConstants.h"
    run %Q|"$BUILT_PRODUCTS_DIR/lktarchiver" #{variant} "#{input_dir}/LKTSpecDefs/lktspec.dtd" "#{input_dir}/LKTSpecDefs" "#{lktspec_file}"|
    run %Q|"$BUILT_PRODUCTS_DIR/iapconstantgen" "#{lktspec_file}" "#{iapconstants_file}" "#{rtconstants_file}"|

    ### I2MArchive ###
    iap2messages_file = internal ? "#{input_dir}/Messages/iap2messages_internal.xml" : "#{input_dir}/Messages/iap2messages.xml"
    run %Q|"$BUILT_PRODUCTS_DIR/i2marchiver" #{variant} "#{output_dir}/iap2messages.i2mspecarchive" "#{iap2messages_file}"|

    ### RulesParser ###
    build_version = run(%Q[grep ATS_BUNDLE_VERSION_SHORT "#{project_dir}/ATSMacApp/InfoPlistPrefix.h" | awk '{print $3}']).strip
    build_revision = run(%Q[grep ATS_BUNDLE_VERSION_REVISION "#{project_dir}/ATSMacApp/InfoPlistPrefix.h" | awk '{print $3}']).strip

    run %Q|"$BUILT_PRODUCTS_DIR/RulesParser" \
    -rulesXML "#{input_dir}/Rules/rules.xml" \
    -rulesDTD "#{input_dir}/Rules/rules.dtd" \
    -resultsDir "#{output_dir}" \
    -appName "ATS" \
    -buildVersion "#{build_version}" \
    -buildRevision "#{build_revision}" \
    -internal #{internal_boolean_string} \
    -mapsDir "#{input_dir}/SpecMaps"|

    ### Generate iAP2 Constants ###
    run %Q|"$BUILT_PRODUCTS_DIR/iap2constantgen" "#{output_dir}/iap2messages.i2mspecarchive" "#{output_dir}/iAP2Constants.h" "#{output_dir}/iAP2Constants.m" "#{input_dir}/Messages/iap2_enum_aliases.txt" #{internal_boolean_string}|

    ### Generate CarPlay messages ###
    run %Q|"$BUILT_PRODUCTS_DIR/TKMessageGenerator" "#{input_dir}/Messages/CarPlayMessages.xml" "#{output_dir}/CarPlayMessages" 0|

    ### Generate Checksum for the auto generated source directory ###
    puts "Generating checksum of the auto generated output directory…"
    output_dir_checksum = computeChecksumsOf(output_dir)

    return output_dir_checksum
end

def computeChecksumsOf(dir)
    checksum = run(%Q[find -s #{dir} -type f \\\( ! -iname '.*' \\\) -exec md5 -q {} \\\; \| md5 -q]).strip
    return checksum
end


PROJECT_DIRECTORY = ENV["PROJECT_DIR"]
raise("the PROJECT_DIR environment variable must be set") if PROJECT_DIRECTORY.nil?

INPUT_DIR = "Input"
OUTPUT_DIR = "AutoGeneratedOutput"
CONFIG_DIR = "Configurations"
SOURCE_CODE_GEN_DIR = File.join(PROJECT_DIRECTORY, "CaptureKit/SourceCodeGeneration/")
INPUT_DIR_PATH = File.join(SOURCE_CODE_GEN_DIR, INPUT_DIR)
OUTPUT_DIR_PATH = File.join(SOURCE_CODE_GEN_DIR, OUTPUT_DIR)
CONFIG_DIR_PATH = File.join(SOURCE_CODE_GEN_DIR, CONFIG_DIR)
CHECKSUM_YML_FILE_PATH = File.join(SOURCE_CODE_GEN_DIR, "AutoGeneratedMD5.yml")

Dir.mktmpdir do |tmp_output_dir|
    puts "Autogenerating source in a temp dir: #{tmp_output_dir}…"
    tmp_output_dir_checksum = autoGenerateSource(PROJECT_DIRECTORY, INPUT_DIR_PATH, tmp_output_dir)

    puts "Computing checksum for config, input, and output…"
    config_dir_checksum = computeChecksumsOf(CONFIG_DIR_PATH)
    input_dir_checksum = computeChecksumsOf(INPUT_DIR_PATH) 
    output_dir_checksum = ""
    if File.directory?(OUTPUT_DIR_PATH)
        output_dir_checksum = computeChecksumsOf(OUTPUT_DIR_PATH)
    end
    puts "Checksum of:\nConfig:#{config_dir_checksum}\nInput:#{input_dir_checksum}\nOutput:#{output_dir_checksum}\n"

    # Read back the MD5s from yaml file
    if File.file?(CHECKSUM_YML_FILE_PATH)
        puts "Found existing checksum yaml file"
        stored_checksums = YAML.load_file(CHECKSUM_YML_FILE_PATH)
        stored_config_dir_checksum = stored_checksums[CONFIG_DIR].strip
        stored_input_dir_checksum = stored_checksums[INPUT_DIR].strip
        stored_output_dir_checksum = stored_checksums[OUTPUT_DIR].strip
        puts "Checksum of:\nStored Config:#{stored_config_dir_checksum}\nStored Input:#{stored_input_dir_checksum}\nStored Output:#{stored_output_dir_checksum}\n"

        if stored_config_dir_checksum == config_dir_checksum && stored_input_dir_checksum == input_dir_checksum && tmp_output_dir_checksum == stored_output_dir_checksum  && tmp_output_dir_checksum == output_dir_checksum 
            puts("Source files are unchanged; no need to auto generate; exiting…")
            exit
        end
    end

    # If we reach here, we have to auto generate
    if File.directory?(OUTPUT_DIR_PATH)
        puts "Deleting current output dir #{OUTPUT_DIR_PATH}…"
        FileUtils.rm_rf(OUTPUT_DIR_PATH)
    end

    puts "Copying directory #{tmp_output_dir} to #{OUTPUT_DIR_PATH}…"
    FileUtils.cp_r tmp_output_dir, OUTPUT_DIR_PATH

    puts "Recomputing checksum of the new output directory…"
    output_dir_checksum = computeChecksumsOf(OUTPUT_DIR_PATH)
    puts "Checksum of:\nOutput:#{output_dir_checksum}"
    
    # write hash out as a YAML file
    new_checksums_dict = { CONFIG_DIR => config_dir_checksum, INPUT_DIR => input_dir_checksum, OUTPUT_DIR => output_dir_checksum }
    puts "Writing newly computed checksums #{new_checksums_dict} to #{CHECKSUM_YML_FILE_PATH}…"
    File.write(CHECKSUM_YML_FILE_PATH, new_checksums_dict.to_yaml)
end
